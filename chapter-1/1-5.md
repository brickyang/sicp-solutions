# 练习 1.5

Ben Bitdiddle 发明了一种检测方法，能够确定解释器究竟采用哪种序求值，是采用应用序，还是采用正则序。他定义了下面两个过程：

```bash
(define (p) (p))
(define (test x y)
  (if (= x 0)
      0
      y))
```

而后他求值下面的表达式：

```bash
(test 0 (p))
```

如果某个解释器采用的是应用序求值，Ben 会看到什么样的情况？如果解释器采用正则序求值，他又会看到什么情况？请对你的回答做出解释。（无论采用正则序或者应用序，假定特殊形式 `if` 的求值规则总是一样的。其中的谓词部分先行求值，根据其结果确定随后求值的子表达式部分。）

---

`(define (p) (p))` 部分定义的过程是一个无限调用自身的过程，即调用 `(p)` 会使程序陷入无限循环无法退出。

在对 `(test 0 (p))` 求值时，解释器如果采用正则序求值，会先对表达式进行完全展开然后再求值：

```bash
(if (= 0 0)
    0
    (p))
```

此时由于 `if` 结果为真，该过程返回 `0`，不会再计算 `(p)`。Ben 会看到解释器输出值 `0`，求值过程正常结束。

解释器如果采用应用序求值，会分别对子表达式 `0` 和 `(p)` 求值。其中对 `(p)` 求值会陷入无限循环。此时 Ben 会看到解释器没有输出，且无法结束求值过程，必须使用 `control + z` 强制退出进程。
